
1. Metoda Sito Eratostenesa służy do wykrywania liczb pierwszych. Pozwala znaleźć wszystkie liczby pierwsze mniejsze od zadanej wartości n. Polega to na utworzeniu listy liczb całkowitych od 1 do n i wykreślaniu liczb podzielnych przez inne.
Algorytm:

Wykreśla się liczbę 1,
Poszukuje się, poczynając od ostatniej znalezionej liczby pierwszej (za pierwszym razem od 1) najbliższej niewykreślonej liczby. Liczba ta jest pierwsza. Następnie wykreśla się z listy wszystkie liczby podzielne przez tę liczbę pierwszą
powtarza się krok dwa aż do chwili, gdy znaleziona liczba pierwsza będzie większa od n1/2

( 2 ) Wykorzystując powyższy algorytm, proszę napisać program, który szuka liczb pierwszych mniejszych od podanej przez użytkownika wartości N.
Wartość maksymalna N = 100000. Proszę wykonać zadanie na jednej tablicy

2. ( 4 ) W programie mamy tablicę:

int tab_A[] = {3,5,33,1,7,9,55,1,11,22,12,6,8,4,44,6,42,2,8,26,64,80,16};

oraz procedurę

void swap(int*a, int*b){
int temp;
temp = *a;
*a = *b;
*b = temp;
return;
};

Proszę napisać funkcję ........find_max_wsk (int *, int *) , zwracającą wskaźnik do elementu maksymalnego w tablicy

Proszę napisać procedurę  , sortującą malejąco  tablicę, zgodną z prototypem void sort (int *tab, int n);, w której zostaną wykorzystane funkcje swap oraz find_max_wsk

Następnie przy użyciu procedury sort należy posortować części parzystą i nieparzystą tablicy tab_A (elementy nieparzyste mają indeksy od 0 do 8, a parzyste od 9 do 22)

3. ( 4 ) W programie proszę napisać wykorzystując operatory binarne :procedurę zamieniającą liczbę całkowitą na string reprezentujący jej zapis binarny, zgodną z prototypem : void do_binar(int n, char * wsk), oraz funkcję zgodną z prototypem: unsigned bity(int x, int p, int n)zwracającą n bitów z liczby x od pozycji p - bity numerujemy od najmłodszego

#include <stdio.h>
// p - pozycja , n - to liczba bitów
unsigned bity(int x, int p, int n)
{ return ...............................; }

void do_binar (int n, char *wsk)
{.......}

int main ()
{ unsigned wynik, liczba = 18; // 10010
// deklaracja koniecznych zmiennych
//wypisanie zmiennej liczba z użyciem do_binar
wynik = bity(liczba, 1, 3); // 3 bity od pozycji 1, czyli: 1 001 0
//wypisanie zmiennej wynik z użyciem do_binar
return 0; }

4. ( 3 ) Proszę zaimplementować algorytm sortowania szybkiego oraz przetestować go na tablicy 10 rzeczywistych wartości pseudolosowych z zakresu <-1.50, 5.50>

Quicksort(A,p,r)
if p < r then
    q <- Partition(A, p, r)
    Quicksort(A,p,q)
    Quicksort(A,q+1,r)
    
Partition(A,p,r)
    x <- A[p]
    i <- p - 1
    j <- r + 1
    while TRUE
	repeat j <- j - 1
	    until A[j] <= x
	repeat i <- i + 1
	    until A[i] >= x
	if i < j then
	    swap (A[i],A[j])
	else return j


